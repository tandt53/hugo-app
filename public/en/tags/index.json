[{"content":"Introduction As in previous post, we discussed about Driver Service (like ChromeDriverService, FirefoxDriverService, etc.). It is to start and stop Driver Server before WebDriver initialized and after quit. So that, service needs to be configured driver executable file (via method useDriverExecutable(File file)). When working with selenium, you should have a driver executor for coresponding browser, like:\n Chrome browser requires chromedriver.exe on Windows, or chromedrive on Linux and Mac. Firefox browser requires geckodriver.exe on Windows, geckodriver on Linux and Mac. Edge browser requires edgedriver.exe on Windows, edgedriver on Mac.  So, what are they responsible for? Why do we need it in Selenium web automation?\nDriver Executor Before we go further, I would remind the log when we start ChromeDriver. It will start a server on free port or on pre-defined port.\nStarting ChromeDriver 91.0.4472.101 (...) on port 5353 ChromeDriver was started successfully. First try Browser drivers are executable, so we can try to run it in command line and check the result.\n$ ./chromedriver Starting ChromeDriver 91.0.4472.101 (...) on port 9515 ChromeDriver was started successfully. Wow, ChromeDriver server was started on port 9515. It was same with using ChromeDriverService in previous post.\nFrom that, we can see that ChromeDriverService get driver executable file and it will start ChromeDriver server internally in selenium code. Then the other services(FirefoxDriverService, EdgeDriverService) do the same way to start browser Server.\nFind more with --help Now, we will explore chromedriver by run it with parameter --help to understand more options.\n$ ./chromedriver --help Usage: ./chromedriver [OPTIONS] Options --port=PORT port to listen on --adb-port=PORT adb server port --log-path=FILE write server log to file instead of stderr, increases log level to INFO --log-level=LEVEL set log level: ALL, DEBUG, INFO, WARNING, SEVERE, OFF --verbose log verbosely (equivalent to --log-level=ALL) --silent log nothing (equivalent to --log-level=OFF) --append-log append log file instead of rewriting --replayable (experimental) log verbosely and don't truncate long strings so that the log can be replayed. --version print the version number and exit --url-base base URL path prefix for commands, e.g. wd/url --readable-timestamp add readable timestamps to log --enable-chrome-logs show logs from the browser (overrides other logging options) --allowed-ips comma-separated allowlist of remote IP addresses which are allowed to connect to ChromeDriver There are so many options available that driver server can start with.\nFor example:\n To check chromedriver version, use --version  $ ./chromedriver --version ChromeDriver 91.0.4472.101 (...)  To start ChromeDriver server with specific port (5353), use --port   ./chromedriver --port=5353 Starting ChromeDriver 91.0.4472.101 (...) on port 5353 ChromeDriver was started successfully. Selenium Driver installed by npm Normally, you would search for chromedriver on Chromium site and download it and put it somewhere on your local machine. Some engineers use WebDriverManager to install automatically.\nIn some cases, you might install chromedriver or geckodriver via node package manager (npm).\nCommand: npm i -g chromedriver.\nThis command will download chromedriver executor and put it somewhere in your machine (on Mac: /usr/local/lib/node_modules/chromedriver/bin/chromedriver).\nThis way shows some advantages as following:\n chromedriver can be installed automatically by scripts. Effortless version selection by command npm i chromedriver@\u0026lt;version\u0026gt; During initializing WebDriver for Chrome, you should not need set property System.setProperty(\u0026quot;webdriver.chrome.driver\u0026quot;, \u0026quot;/path/to/chromedriver\u0026quot;);  ","description":"Understand what really deriver executors (ChromeDriver.exe, GeckoDriver.exe, EdgeDriver.exe) are.","id":0,"section":"selenium","tags":null,"title":"Selenium Driver Executor","uri":"https://www.tandt53.dev/en/selenium/selenium-driver-executor/"},{"content":"Introduction In this post, I would like to introduce the different ways to initialize instance of WebDriver. It will help you understand more clearly about Selenium Architecture.\nThis post focuses on ChromeDriver constructors:\n No argument constructor: public ChromeDriver() Constructor with 1 parameter ChromeDriverService: public ChromeDriver(ChromeDriverService service)  No argument constructor Firstly, I created a sample source code for initialize ChromeDriver instance:\n1 2 3 4  String chromeDriverFilePath = \u0026#34;chromedriver\u0026#34;; // I downloaded chromedriver and put it in the root directory of project. On mac, the executor is chromedriver, but on Windows, using chromedriver.exe instead. System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, chromeDriverFilePath); WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com.vn\u0026#34;);   Above codes will start a selenium session and launch Google Chrome browser. Then it navigate to home page of google search. Let\u0026rsquo;s run programm, we can see the log as follow:\nStarting ChromeDriver 91.0.4472.101 (...) on port 8945 ChromeDriver was started successfully. It shows that ChromeDriver was started successfully on port 8945. It means that there is some server was started on my machine on port 8945. But I did not set any thing like port or server options in our code. Where did they come from? Is ChromeDriver a server?\nWe will answer those question in next session.\nConstructor with 1 parameter ChromeDriverService Let\u0026rsquo;s create an instance of ChromeDriverService via Builder and then create ChromeDriver with that.\n1 2 3 4 5 6 7  String chromeDriverFilePath = \u0026#34;chromedriver\u0026#34;; ChromeDriverService.Builder builder = new ChromeDriverService.Builder(); builder.usingAnyFreePort(); builder.usingDriverExecutable(new File(chromeDriverFilePath)); ChromeDriverService service = builder.build(); WebDriver driver = new ChromeDriver(service); driver.get(\u0026#34;https://google.com.vn\u0026#34;);   The code shows that service will be built after set 2 information for builder (usingAnyFreePort, and usingDriverExecutable is a file of chromedriver). Then that instance is passed into constructor of ChromeDriver then navigate to Google Search. Now run the program to see the behavior nothing different but log:\nStarting ChromeDriver 91.0.4472.101 (...) on port 29284 ChromeDriver was started successfully. Let\u0026rsquo;s change a little bit in our code:\n1 2 3 4 5 6 7 8 9  ChromeDriverService.Builder builder = new ChromeDriverService.Builder(); builder.usingPort(5353); // change builder.usingDriverExecutable(new File(\u0026#34;chromedriver\u0026#34;)); ChromeDriverService service = builder.build(); service.start(); // new line WebDriver driver = new ChromeDriver(service); driver.get(\u0026#34;https://google.com.vn\u0026#34;); driver.quit(); // new line service.stop(); // new line   There are 4 lines updated:\n line 2: we changed builder using any free port by a specific port number (5353). line 5: service is started before create instance of ChromeDriver. line 7: driver is quit after navigate to Google search. line 8: service is stopped after driver quit.\nNow run program once again and check the console log:  Starting ChromeDriver 91.0.4472.101 (...) on port 5353 ChromeDriver was started successfully. This time, ChromeDriver server was started on port 5353, as we set in builder of service. Now we understand that ChromeDriverService will be incharged of initiate ChromeDriver server using configured informations (port and driver executable file). And we can control those configuration (starting server in different port, or using different version of chromedriver) as we want.\nSummary From above code, we see that out test scripts will start an driver server (ChromeDriver server, GeckoDriver server, etc.) whenever we call new instance of WebDriver for corresponding browser. Then, every command (click, sendKeys, getText, etc.) will be transformed from script (selenium client) to that server to interact with browser, and finaly get result.\nIn next post, I will present about driver executable file (chromedriver.exe, geckodriver.exe) for more details.\n","description":"Details in browser service classes in selenium, like ChromeDriverService, FirefoxDriverService,...","id":1,"section":"selenium","tags":["selenium","selenium-webdriver","driver-service","ChromeDriverService","FirefoxDriverService","SafariDriverService","EdgeDriverService"],"title":"Selenium Driver Service","uri":"https://www.tandt53.dev/en/selenium/selenium-service/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n\n","description":"Hugo, the worldâ€™s fastest framework for building websites","id":2,"section":"","tags":null,"title":"About","uri":"https://www.tandt53.dev/en/about/"}]