[{"content":"Introduction Trong bài viết trước, ta đã tìm hiểu về Driver Service là các class ChromeDriverService, FirefoxDriverService,\u0026hellip; và biết được rằng các service class này sẽ start trước khi WebDriver được khởi tạo và stop Driver Server sau khi driver quit. Để làm được điều này cần phải xác định file thực thi phù hợp với từng loại trình duyệt:\n Chrome yêu cầu chromedriver.exe trên Windows, hoặc chromedriver trênn Linux và Mac Firefox yêu cầu geckodriver.exe trên Windows, hoặc geckodriver trênn Linux và Mac.\nTrong bài viết này sẽ giúp bạn hiểu rõ hơn các file này làm nhiệm vụ gì và tại sao chúng ta lại cần nó khi thực hiện automation test cho web sử dụng Selenium.  Driver Executor Trước khi bắt đầu, ta nhắc lại 1 chút về log khi khởi tạo ChromeDriver: 1 ChromeDriver sẽ được start ở 1 port bất kỳ hoặc 1 port được xác định trước.\nStarting ChromeDriver 91.0.4472.101 (...) on port 5353 ChromeDriver was started successfully. Thử lần 1 Ta gọi các file chromedriver.exe là các file thực thi (executor), vì vậy hãy thử chạy file này ở command line xem sao.\n chuyển tới thư mục chứa file thực thi: cd \u0026lt;folder-contain-executor\u0026gt; chạy file thực thi đó: chromedriver.exe trên Windows, hoặc ./chromedriver trên Mac hoặc Linux  $ ./chromedriver Starting ChromeDriver 91.0.4472.101 (...) on port 9515 ChromeDriver was started successfully. Có thể thấy ChromeDriver server được khởi chạy ở port 9515. Dòng log giống với khi ta chạy code automation ở trên. Từ đó có thể thấy rằng, class ChromeDriverService của Selenium sẽ nhận file từ đường dẫn cho trước, và sẽ dùng chính file đó để start và stop ChromeDriver server. Tương tự như vậy, các class driver service khác cũng làm điều tương tự.\nThử lần 2 với tham số --help Bây giờ ta sẽ khám phá thêm về các cấu hình có thể lựa chọn khi chạy file thực thi, bằng việc chạy câu lệnh với tham số --help.\n$ ./chromedriver --help Usage: ./chromedriver [OPTIONS] Options --port=PORT port to listen on --adb-port=PORT adb server port --log-path=FILE write server log to file instead of stderr, increases log level to INFO --log-level=LEVEL set log level: ALL, DEBUG, INFO, WARNING, SEVERE, OFF --verbose log verbosely (equivalent to --log-level=ALL) --silent log nothing (equivalent to --log-level=OFF) --append-log append log file instead of rewriting --replayable (experimental) log verbosely and don't truncate long strings so that the log can be replayed. --version print the version number and exit --url-base base URL path prefix for commands, e.g. wd/url --readable-timestamp add readable timestamps to log --enable-chrome-logs show logs from the browser (overrides other logging options) --allowed-ips comma-separated allowlist of remote IP addresses which are allowed to connect to ChromeDriver Có khá nhiều lựa chọn cho ta có thể cấu hình khi khởi chạy ChromeDriver server.\nVí dụ:\n Để kiểm tra chromedriver version, ta dùng --version  $ ./chromedriver --version ChromeDriver 91.0.4472.101 (...)  Để khởi chạy ChromeDriver server ở 1 port mà mình mong muốn (5353) có thể dùng --port   ./chromedriver --port=5353 Starting ChromeDriver 91.0.4472.101 (...) on port 5353 ChromeDriver was started successfully. Và còn rất nhiều các cấu hình khác nữa, các bạn đọc có thể thử để khám phá thêm.\nSelenium Driver cài đặt bởi npm Thông thường, ta thường tải chromedriver từ trang chủ Chromium, rồi đặt nó ở 1 thư mục nào đó trên máy của chúng ta. Một số bạn có thể dùng WebDriverManager để tự động tải về.\nBài viết này sẽ giới thiệu thêm 1 cách nữa, đó là dùng node package manager (npm) của nodejs.\nCommand: npm i -g chromedriver.\n Command này sẽ tải chromedriver về và lưu ở 1 folder nhất định (trên Mac /usr/local/lib/node_modules/chromedriver/bin/chromedriver). Khi khởi tạo instance WebDriver, ta không cần set thêm thuộc tính System.setProperty(\u0026quot;webdriver.chrome.driver\u0026quot;, \u0026quot;/path/to/chromedriver\u0026quot;); (đã test trên Mac - các bạn thử test trên Windows và Linux xem). Với cách này ta có thể tạo ra các script (shell, batch,python\u0026hellip;) để tải về chromedriver mà không cần tải bằng tay nữa. Thêm nữa, việc lựa chọn các version khác nhau cũng có thể chỉnh trong script npm i chromedriver@\u0026lt;version\u0026gt;  ","description":"Bài viết giúp bạn hiểu rõ hơn về các file driver executors (ChromeDriver.exe, GeckoDriver.exe, EdgeDriver.exe).","id":0,"section":"selenium","tags":null,"title":"Selenium Driver Executor","uri":"https://www.tandt53.dev/vi/selenium/selenium-driver-executor/"},{"content":"Introduction Trong bài viết này sẽ giới thiệu cách cách khác nhau để khởi tạo instance của WebDriver, giúp cho bạn hiểu rõ hơn về kiến trúc của Selenium.\nBài viết sẽ tập trung vào các constructor của ChromeDriver:\n Constructor không tham số: public ChromeDriver() Constructor có 1 tham số ChromeDriverService: public ChromeDriver(ChromeDriverService service)  Constructor không tham số Đầu tiên, hãy tạo một đoạn code thông thường để khởi tạo ChromeDriver:\n1 2 3 4  String chromeDriverFilePath = \u0026#34;chromedriver\u0026#34;; // I downloaded chromedriver and put it in the root directory of project. On mac, the executor is chromedriver, but on Windows, using chromedriver.exe instead. System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, chromeDriverFilePath); WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com.vn\u0026#34;);   Đoạn code trên sẽ khởi tạo 1 session selenium và mở trình duyệt Chrome trên máy local. Sau đó sẽ chyển tới tran Google search. Giờ hãy xem log khi chạy đoạn code này:\nStarting ChromeDriver 91.0.4472.101 (...) on port 8945 ChromeDriver was started successfully. Đây là phần log đã được rút gọn, chỉ thể hiện phần nội dung mà chúng ta sẽ quan tâm trong bài viết này.\nĐoạn log ở trên cho ta thấy ChromeDriver đã được khởi chạy thành công ở port 8945. Tức là đang có 1 server nào đó được khởi tạo ở máy local lắng nghe ở port 8945. Nhưng trong code chúng ta không hề thấy dòng nào là start server cả, chúng ta chỉ khởi tạo instance của ChromeDriver và mở trình duyệt thôi mà. Vậy đoạn log này là do đâu? ChromeDriver có phải là 1 server?\nPhần tiếp theo chúng ta sẽ đi tìm câu trả lời cho các câu hỏi này.\nConstructor có 1 tham số ChromeDriverService Lần này chúng ta sẽ thay đổi code 1 chút, khởi tạo instance của ChromeDriver với constructor 1 tham số.\n1 2 3 4 5 6 7  String chromeDriverFilePath = \u0026#34;chromedriver\u0026#34;; ChromeDriverService.Builder builder = new ChromeDriverService.Builder(); builder.usingAnyFreePort(); builder.usingDriverExecutable(new File(chromeDriverFilePath)); ChromeDriverService service = builder.build(); WebDriver driver = new ChromeDriver(service); driver.get(\u0026#34;https://google.com.vn\u0026#34;);   Chương trình trên cho thấy 1 service sẽ được tạo thành từ builder sau khi đã set 2 thông tin (usingAnyFreePort(), và usingDriverExecutable() đường dẫn tới file chromedriver). Sau đó instance service đó được truyền vào tham số của ChromeDriver để khởi tạo instance driver. Tiếp theo chúng ta sẽ chạy thử để xem có gì khác biệt so với code ở phần trước không.\nStarting ChromeDriver 91.0.4472.101 (...) on port 29284 ChromeDriver was started successfully. Ta thấy ChromeDervice đã được khởi chạy thành công, nhưng ở port khác. Tiếp theo ta sẽ thử thay đổi code 1 chút nữa:\n1 2 3 4 5 6 7 8 9  ChromeDriverService.Builder builder = new ChromeDriverService.Builder(); builder.usingPort(5353); // change builder.usingDriverExecutable(new File(\u0026#34;chromedriver\u0026#34;)); ChromeDriverService service = builder.build(); service.start(); // new line WebDriver driver = new ChromeDriver(service); driver.get(\u0026#34;https://google.com.vn\u0026#34;); driver.quit(); // new line service.stop(); // new line   Có 4 sự thay đổi ở đoạn code ở trên:\n Dòng 2: chỉ đích danh port 5353 cho builder. Dòng 5: service được start trước khi khởi tạo instance của ChromeDriver. Dòng 7: gọi method driver.quit() sau khi đã mở trình duyệt và chuyển tới trang google search. Dòng 8: service được stop sau khi driver quit.\nTiếp tục chạy lần nữa để xem log nhé:  Starting ChromeDriver 91.0.4472.101 (...) on port 5353 ChromeDriver was started successfully. Lần này ChromeDriver server đã được khởi chạy ở port 5353, đúng như số port ta đã set trong code. Điều này cho thấy ChromeDriverService sẽ đảm nhiệm việc khởi chạy ChromeDriver server, với cấu hình cho trước (hoặc mặc định). Vì vậy, chúng ta hoàn toàn có thể điều chỉnh các cấu hình này để khởi chạy server ở các port khác nhau, sử dụng các chromedriver file khác nhau.\nSummary Từ việc thử nghiệm các đoạn code ở trên, chúng ta có thể thấy test script sẽ khởi chạy 1 driver server (có thể là ChromeDriver server, hoặc GeckoDriver server\u0026hellip;) ngay khi khởi tạo instance của WebDriver. Server này chúng ta hoàn toàn có thể điều chỉnh cho phù hợp với mục đích của mình.\nSau khi driver server được khởi chạy, các lệnh như click, sendKeys, getText\u0026hellip; từ script (selenium client) sẽ được chuyển thành các request gửi tới driver server để tương tác với browser và trả về kết quả.\nTrong bài viết tiếp theo, ta sẽ tìm hiểu chi tiết hơn về các file driver executor (chromedriver.exe, geckodriver.exe,\u0026hellip;)\n","description":"Cách khởi tạo instance WebDriver với các service class với selenium, như ChromeDriverService, FirefoxDriverService,...","id":1,"section":"selenium","tags":["selenium","selenium-webdriver","driver-service","ChromeDriverService","FirefoxDriverService","SafariDriverService","EdgeDriverService"],"title":"Selenium Driver Service","uri":"https://www.tandt53.dev/vi/selenium/selenium-service/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n\n","description":"Giới thiêu về tandt53","id":2,"section":"","tags":null,"title":"Giới thiệu","uri":"https://www.tandt53.dev/vi/about/"}]